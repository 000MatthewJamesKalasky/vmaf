__copyright__ = "Copyright 2016, Netflix, Inc."
__license__ = "Apache, Version 2.0"

import os
import multiprocessing
import subprocess
import config
from tools import get_dir_without_last_slash, make_parent_dirs_if_nonexist
from executor import Executor
from result import Result

class QualityRunner(Executor):
    """
    QualityRunner takes in a list of assets, and run feature extraction on
    them, and return a list of corresponding results. A QualityRunner must
    specify a unique type and version combination (by the TYPE and VERSION
    attribute), so that the Result generated by it can be identified.
    """

    def _read_result(self, asset):

        result = {}

        # add quality scores
        result.update(self._get_quality_scores(asset))

        # add dis video file bitrate (must be an entire file)
        dis_bitrate_kbps = asset.dis_bitrate_kbps_for_entire_file
        dis_bitrate_key = "dis_bitrate_kbps"
        result[dis_bitrate_key] = dis_bitrate_kbps

        return Result(asset, self.executor_id, result)

def run_quality_runners_in_parallel(runner_class,
                                    assets,
                                    log_file_dir=config.ROOT + "/workspace/log_file_dir",
                                    fifo_mode=True,
                                    delete_workdir=True,
                                    parallelize=True,
                                    logger=None
                                    ):
    """
    Run multiple QualityRunner in parallel.
    :param runner_class:
    :param assets:
    :param log_file_dir:
    :param fifo_mode:
    :param delete_workdir:
    :param parallelize:
    :return:
    """

    def run_quality_runner(args):
        runner_class, asset, log_file_dir, fifo_mode, delete_workdir = args
        runner = runner_class(
            [asset], None, log_file_dir, fifo_mode, delete_workdir)
        runner.run()
        return runner

    # pack key arguments to be used as inputs to map function
    list_args = []
    for asset in assets:
        list_args.append(
            [runner_class, asset, log_file_dir, fifo_mode, delete_workdir])

    # map arguments to func
    if parallelize:
        try:
            from pathos.pp_map import pp_map
            runners = pp_map(run_quality_runner, list_args)
        except ImportError:
            # fall back
            msg = "pathos.pp_map cannot be imported, fall back to sequential " \
                  "map(). Install pathos by: \npip install pathos"
            if logger:
                logger.warn(msg)
            else:
                print 'Warn: {}'.format(msg)
            runners = map(run_quality_runner, list_args)
    else:
        runners = map(run_quality_runner, list_args)

    # aggregate results
    results = [runner.results[0] for runner in runners]

    return runners, results
