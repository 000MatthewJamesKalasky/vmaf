__copyright__ = "Copyright 2016, Netflix, Inc."
__license__ = "Apache, Version 2.0"

import config
from executor import Executor
from result import Result
import sys
import numpy as np
from feature_assembler import FeatureAssembler
from train_test_model import LibsvmnusvrTrainTestModel, TrainTestModel


class QualityRunner(Executor):
    """
    QualityRunner takes in a list of assets, and run feature extraction on
    them, and return a list of corresponding results. A QualityRunner must
    specify a unique type and version combination (by the TYPE and VERSION
    attribute), so that the Result generated by it can be identified.

    Two category of subclassing QualityRunners: 1) calling external quality
    metric (e.g. PSNR or AWCY SSIM) directly to get the quality scores.
    2) calling internal FeatureExtractor for features followed by calling
    internal TrainTestModels.predict().
    """

    def _read_result(self, asset):

        result = {}
        result.update(self._get_quality_scores(asset))
        return Result(asset, self.executor_id, result)

    @classmethod
    def get_scores_key(cls):
        return cls.TYPE + '_scores'

    @classmethod
    def get_score_key(cls):
        return cls.TYPE + '_score'

class VmafQualityRunner(QualityRunner):

    TYPE = 'VMAF'
    VERSION = '0.1'

    FEATURE_ASSEMBLER_DICT = {'VMAF_feature': 'all'}

    FEATURE_RESCALE_DICT = {'VMAF_feature_vif_scores': (0.0, 1.0),
                            'VMAF_feature_adm_scores': (0.4, 1.0),
                            'VMAF_feature_ansnr_scores': (10.0, 50.0),
                            'VMAF_feature_motion_scores': (0.0, 20.0)}

    SVM_MODEL_FILE = config.ROOT + "/resource/model/model_V8a.model"

    # model_v8a.model is trained with customized feature order:
    SVM_MODEL_ORDERED_SCORES_KEYS = ['VMAF_feature_vif_scores',
                                     'VMAF_feature_adm_scores',
                                     'VMAF_feature_ansnr_scores',
                                     'VMAF_feature_motion_scores']

    sys.path.append(config.ROOT + "/libsvm/python")
    import svmutil

    asset2quality_map = {}

    def _get_vmaf_feature_assembler_instance(self, asset):
        vmaf_fassembler = FeatureAssembler(
            feature_dict=self.FEATURE_ASSEMBLER_DICT,
            feature_option_dict=None,
            assets=[asset],
            logger=self.logger,
            log_file_dir=self.log_file_dir,
            fifo_mode=self.fifo_mode,
            delete_workdir=self.delete_workdir,
            result_store=self.result_store
        )
        return vmaf_fassembler

    # override Executor._run_on_asset
    def _run_on_asset(self, asset):
        """
        Override Executor._run_on_asset to bypass calling
        _run_and_generate_log_file() itself. Instead, initiate a
        FeatureAssembler object and run, which will do the work.
        :param asset:
        :return:
        """
        vmaf_fassembler = self._get_vmaf_feature_assembler_instance(asset)
        vmaf_fassembler.run()
        feature_result = vmaf_fassembler.results[0]

        # =====================================================================

        # SVR predict
        model = self.svmutil.svm_load_model(self.SVM_MODEL_FILE)

        ordered_scaled_scores_list = []
        for scores_key in self.SVM_MODEL_ORDERED_SCORES_KEYS:
            scaled_scores = self._rescale(feature_result[scores_key],
                                          self.FEATURE_RESCALE_DICT[scores_key])
            ordered_scaled_scores_list.append(scaled_scores)

        scores = []
        for score_vector in zip(*ordered_scaled_scores_list):
            vif, adm, ansnr, motion = score_vector
            xs = [[vif, adm, ansnr, motion]]
            score = self.svmutil.svm_predict([0], xs, model)[0][0]
            score = self._post_correction(motion, score)
            scores.append(score)

        quality_result = {}

        # add all feature result
        quality_result.update(feature_result.result_dict)

        # add quality score
        quality_result[self.get_scores_key()] = scores

        # save to asset2quality map
        self.asset2quality_map[repr(asset)] = quality_result

        result = self._read_result(asset)

        return result

    def _post_correction(self, motion, score):
        # post-SVM correction
        if motion > 12.0:
            val = motion
            if val > 20.0:
                val = 20
            score *= ((val - 12) * 0.015 + 1)
        if score > 100.0:
            score = 100.0
        elif score < 0.0:
            score = 0.0
        return score

    @classmethod
    def _rescale(cls, vals, lower_upper_bound):
        lower_bound, upper_bound = lower_upper_bound
        vals = np.double(vals)
        vals = np.clip(vals, lower_bound, upper_bound)
        vals = (vals - lower_bound) / (upper_bound - lower_bound)
        return vals

    def _get_quality_scores(self, asset):
        """
        Since result already stored in asset2quality map, just retrieve it
        :param asset:
        :return:
        """
        repr_asset = repr(asset)
        assert repr_asset in self.asset2quality_map
        return self.asset2quality_map[repr_asset]

    def _remove_log(self, asset):
        """
        Remove VmafFeatureExtractor's log instead
        :param asset:
        :return:
        """
        vmaf_fassembler = self._get_vmaf_feature_assembler_instance(asset)
        vmaf_fassembler.remove_logs()

    def _remove_result(self, asset):
        """
        Remove VmafFeatureExtractor's result instead
        :param asset:
        :return:
        """
        vmaf_fassembler = self._get_vmaf_feature_assembler_instance(asset)
        vmaf_fassembler.remove_results()

class Vmaf2QualityRunner(QualityRunner):
    TYPE = 'VMAF2'
    VERSION = '0.1'

    FEATURE_ASSEMBLER_DICT = {'VMAF_feature': 'all'}

    SVM_MODEL_FILE = config.ROOT + "/resource/model/model_v9.model"

    def _get_vmaf_feature_assembler_instance(self, asset):
        vmaf_fassembler = FeatureAssembler(
            feature_dict=self.FEATURE_ASSEMBLER_DICT,
            feature_option_dict=None,
            assets=[asset],
            logger=self.logger,
            log_file_dir=self.log_file_dir,
            fifo_mode=self.fifo_mode,
            delete_workdir=self.delete_workdir,
            result_store=self.result_store
        )
        return vmaf_fassembler

    asset2quality_map = {}

    # override Executor._run_on_asset
    def _run_on_asset(self, asset):
        """
        Override Executor._run_on_asset to bypass calling
        _run_and_generate_log_file() itself. Instead, initiate a
        FeatureAssembler object and run, which will do the work.
        :param asset:
        :return:
        """
        vmaf_fassembler = self._get_vmaf_feature_assembler_instance(asset)
        vmaf_fassembler.run()
        feature_result = vmaf_fassembler.results[0]

        xs = LibsvmnusvrTrainTestModel.get_perframe_xs_from_result(feature_result)

        model = LibsvmnusvrTrainTestModel.from_file(self.SVM_MODEL_FILE, None)

        ys_pred = model.predict(xs)
        ys_pred = np.clip(ys_pred, 0.0, 100.0)

        quality_result = {}

        # add all feature result
        quality_result.update(feature_result.result_dict)

        # add quality score
        quality_result[self.get_scores_key()] = ys_pred

        # save to asset2quality map
        self.asset2quality_map[repr(asset)] = quality_result

        result = self._read_result(asset)

        return result

    def _get_quality_scores(self, asset):
        """
        Since result already stored in asset2quality map, just retrieve it
        :param asset:
        :return:
        """
        repr_asset = repr(asset)
        assert repr_asset in self.asset2quality_map
        return self.asset2quality_map[repr_asset]

    def _remove_log(self, asset):
        """
        Remove VmafFeatureExtractor's log instead
        :param asset:
        :return:
        """
        vmaf_fassembler = self._get_vmaf_feature_assembler_instance(asset)
        vmaf_fassembler.remove_logs()

    def _remove_result(self, asset):
        """
        Remove VmafFeatureExtractor's result instead
        :param asset:
        :return:
        """
        vmaf_fassembler = self._get_vmaf_feature_assembler_instance(asset)
        vmaf_fassembler.remove_results()
